\documentclass[pdftex,12pt,a4paper]{article}

\usepackage[pdftex]{graphicx}
\usepackage{url}
\usepackage{verbatim}

\usepackage{xspace}
\newcommand{\CEU}{\textsc{C\'{e}u}\xspace}
\newcommand{\GVT}{\textsc{LuaGravity}\xspace}
\newcommand{\code}[1] {{\small{\texttt{#1}}}}

\usepackage{color}
    \definecolor{light}{gray}{0.92}
    \definecolor{dark}{gray}{0.30}
    %\definecolor{light}{rgb}{.90,.90,.90}
    \definecolor{darkgreen}{rgb}{0,.50,0}
    \definecolor{darkblue}{rgb}{0,0,.50}
    \definecolor{darkred}{rgb}{.50,0,0}
    \definecolor{darkpur}{rgb}{.50,0,.50}

\usepackage{listings}
%\usepackage{textcomp}
\lstset{
%columns=fullflexible,
%basicstyle=\ttfamily,
escapeinside={||},
mathescape=true,
    language=C, % choose the language of the code
    basicstyle=\fontfamily{pcr}\selectfont\scriptsize\color{black},
    keywordstyle=\color{black}\bfseries, % style for keywords
    numbers=none, % where to put the line-numbers
    numberstyle=\tiny, % the size of the fonts that are used for the line-numbers
    backgroundcolor=\color{light},
    showspaces=false, % show spaces adding particular underscores
    showstringspaces=false, % underline spaces within strings
    showtabs=false, % show tabs within strings adding particular underscores
    %frame=single, % adds a frame around the code
    tabsize=2, % sets default tabsize to 2 spaces
    %rulesepcolor=\color{gray}
    captionpos=t, % sets the caption-position to bottom
    breaklines=false, % sets automatic line breaking
    %breakatwhitespace=false,
    numbersep=2em,
    emph={par,or,hor,do,end,loop,await,emit,input,every,event,call,with,command,%
          var,and,then,else,C,return,pure,deterministic,nohold,finalize,%
          each, abort, when, signal, FOREVER, class, spawn, native, safe},
    emphstyle={\bfseries},
    commentstyle=\color{dark}\scriptsize,
    %xleftmargin=20pt,
    %xrightmargin=20pt,
    framesep=20pt,
    %upquote=true,
    %aboveskip={1.5\baselineskip},
}

%\renewcommand{\chaptername}{}
%\renewcommand{\thesection}{}
%\setcounter{chapter}{-1}

\begin{document}

\begin{titlepage}
\begin{center}

\textsc{\LARGE PUC--Rio}\\[1.5cm]
\textsc{\Large Research Plan}\\[0.8cm]

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\HRule \\[0.4cm]
{ \huge \bfseries Synchronous Languages for
                  General Purpose Reactive Systems }\\[0.4cm]
\HRule \\[1.5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Autor:}\\
Francisco Sant'Anna
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Advisors:} \\
Roberto Ierusalimschy \\
Noemi Rodriguez
\end{flushright}
\end{minipage}

\vfill
{\large \today}
\end{center}
\end{titlepage}

\tableofcontents

\newpage
\section{Abstract}

The proposed research plan, entitled ``Synchronous Languages for General 
Purpose Reactive Systems'', aims to expand the use of static and 
safety-oriented synchronous languages to embrace general purpose reactive 
systems, such as GUIs, games, multimedia, and networked applications.

Synchronous languages typically target critical embedded systems, relying on a 
restricted semantics to enable static analysis in programs and provide a number 
of compile-time safety guarantees.
%
On the one hand, synchronous programs are predictable in terms of memory usage, 
execution time, and behavior.
%
On the other hand, they are limited in expressiveness, restricting support for 
dynamic memory allocation and for describing algorithmic-intensive 
computations.
%
Although these limitations are not impeditive in the context of embedded 
systems, they are unacceptable for general purpose reactive programming.

Our goal is to study how to tune the safety and expressiveness boundaries of
synchronous languages in a way that reactive applications can benefit of 
powerful mechanisms, while retaining as much efficiency and safety guarantees 
as possible.

\section{Introduction}

Concurrent languages can be generically classified in two major execution 
models.
%
In the \emph{asynchronous model}, the program activities (e.g. threads and 
processes) run independently of one another as result of non-deterministic 
preemptive scheduling.
In order to coordinate at specific points, these activities require explicit 
use of synchronization primitives (e.g. mutual exclusion and message passing).
%
In the \emph{synchronous model}, the program activities (e.g. callbacks and 
coroutines) require explicit control/scheduling primitives (e.g. returning or 
yielding).
For this reason, they are inherently synchronized, as the programmer himself 
specifies how they execute and transfer control.

Due to the simpler and disciplined execution model, synchronous languages are 
susceptible to static analysis and verification, being an established 
alternative to $C$ in the field of safety-critical embedded 
systems~\cite{rp.twelve}.
%
However, in order to enable static analysis, synchronous programs typically 
suffer from two main limitations in expressiveness:
\emph{lack of dynamic memory allocation support} and
\emph{impossibility of doing algorithmic-intensive computations}.
%
Memory allocation makes the static prediction about memory usage more 
difficult, transferring the burden of memory management to runtime and to 
programmers, which makes programs less safe.
It also requires programmers to handle pointers explicitly, raising a number of 
safety threats, such as \emph{dangling pointers} and \emph{memory leaks}.
%Furthermore, it affects the performance of programs, given that memory 
%allocation algorithms have some (possibly unpredictable) runtime overhead.
%Finally, heap usage may affect the stack and vice-versa, leading to hard-
%specially considering MMU-less embedded platforms
%
%* mem pools
%
Algorithm-intensive computations (e.g., compression, image processing) break 
the synchronous execution hypothesis, as control transfer among activities now 
happens in an unbounded amount of processing time~\cite{rp.hypothesis}.
%
For reactive applications, instantaneous feedback is fundamental, and minimal 
delays in responsiveness may affect the system correctness.

\CEU~\cite{ceu.tr,ceu.phd,ceu.sensys13,ceu.rem13}
and
\GVT~\cite{luagravity.sblp,luagravity.msc}
are two synchronous languages with distinct goals that we have been developing 
during the past 6 years.

\CEU is a Esterel-based~\cite{esterel.ieee91} reactive language that targets 
constrained embedded platforms.
It is designed from scratch and pursues safety and efficiency, targeting highly 
constrained embedded systems.
Most of the complexity of the language resides on the static analysis that 
happens at compile time.
The compiler forbids unbounded loops and verifies that no two accesses to the 
same variable occur at the same time.
It also calculates exact upper limits for memory usage, concurrent lines of 
execution, and nested invocations of internal events.
Therefore, there are no runtime errors regarding memory allocations, race 
conditions, and unbounded execution.

\GVT provides runtime extensions to the programming language Lua~\cite{lua.pil} 
for a better support for building reactive applications.
\GVT supports the emerging functional reactive programming style (FRP) for 
building declarative GUIs~\cite{frp.flapjax,frp.elm,frp.survey}.
Being an extension module, instead of a new language on its own, \GVT inherits 
all functionality of Lua, with unrestricted support for loops, recursive calls, 
and heap-allocated tables, closures, and coroutines.
Therefore, \GVT pursues power and flexibility, relying on a dynamic language 
that already pushes most safety checks to runtime.

Overall, \CEU produces more tractable and reliable programs, but also rapidly 
hits a limit in expressiveness when used outside its restricted embedded 
domain.
%
Our goal with this research plan is to push the expressiveness limits of \CEU 
towards general purpose reactive systems.
%
Starting from \CEU's restricted and tractable semantics, we can keep the 
precise memory and execution model that allows the compiler to predict resource 
usage.
%
In contrast, most FRP systems expose turing-complete functional languages to 
programmers, and hence, cannot provide static safety guarantees.

\section{Research plan}

Our goal is to extend the expressiveness of the programming language \CEU, 
while accommodating two conflicting requirements:

\begin{itemize}
    \item Keep the safety and resource efficiency of synchronous languages.
    \item Overcome the two main limitations of synchronous languages:
            \emph{dynamic memory allocation}
            and
            \emph{performing algorithmic-intensive computations}.
\end{itemize}

On the one hand, \CEU was designed for constrained embedded systems, and we do 
not want to abdicate of its small footprint and compile-time safety guarantees.
%
On the other hand, to overcome the limitations in expressiveness, we

We want to keep

We believe that it is important to retain
The first item

To attack the limitations

We start with a

keep safety and resource efficiency
    - from constrained embedded systems to general-purpose reactive systems

memory management
    - memory pools
    - scope

xxx
    - asynchronous execution
        - share nothing
        - event-driven model
        - no tweking in the synch formal semantics

\subsection{The programming language C\'eu}

\begin{figure}[t]
\begin{lstlisting}[numbers=left,xleftmargin=3em]
par do
    loop do
        await 250ms;
        _led_toggle(0);
    end
with
    loop do
        await 500ms;
        _led_toggle(1);
    end
with
    loop do
        await 1000ms;
        _led_toggle(2);
    end
end
\end{lstlisting}
\rule{8.6cm}{0.37pt}
\caption{
    An introductory example in \CEU that blinks three LEDs (identified as 0, 1, 
    and 2) in parallel trails.
    The LEDs blink every $250ms$, $500ms$, and $1000ms$, respectively.
    \label{lst.blink}
}
\end{figure}

\CEU~\cite{ceu.sensys13,ceu.phd,ceu.rem13,ceu.tr} is a synchronous reactive 
language that supports multiple lines of execution---known as 
\emph{trails}---that continuously react to external input events broadcast by 
the environment.
%
The example in Figure~\ref{lst.blink} blinks three LEDs in parallel with 
different frequencies.

By following the synchronous model, each trail in \CEU reacts to an occurring 
event with a \emph{run-to-completion} policy: the scheduler of \CEU is 
non-preemptive and deterministic.
%
Reactions to subsequent events never overlap, and the compiler ensures that 
programs do not contain \emph{unbounded loops} (i.e., loops without 
\code{await} statements) which could lead to unresponsiveness for incoming 
events.
%
%Note in the example of Figure~\ref{lst.blink} that every second the three 
%trails awake at the same time, but the deterministic scheduler follows the 
%order they appear in the code (i.e., first \emph{LED 0} toggles, then 
%\emph{LED 1}, and then \emph{LED 2}).

Programs in \CEU are structured with standard imperative primitives, such as 
sequences, loops, and assignments.
The extra support for parallelism allows programs to wait for multiple events 
at the same time.
Trails await events without loosing context information, such as locals and the 
program counter, which eases reasoning in concurrent 
applications~\cite{sync_async.cooperative}.
%
The conjunction of parallelism with standard control-flow enable hierarchical 
compositions, in which self-contained blocks of code can be deployed 
independently.
%
To illustrate the power of compositions in \CEU, consider the two variations of 
the structure that follows:

\begin{minipage}[t]{0.35\linewidth}
\begin{lstlisting}
loop do
    par/and do
        <...>
    with
        await 1s;
    end
end
\end{lstlisting}
\end{minipage}
%
\hspace{1cm}
%
\begin{minipage}[t]{0.35\linewidth}
\begin{lstlisting}
loop do
    par/or do
        <...>
    with
        await 1s;
    end
end
\end{lstlisting}
\end{minipage}

In the \code{par/and} loop variation, the code in the first trail (represented 
as \code{...}) is repeated every second at minimum, as the second trail must 
also terminate to rejoin the \code{par/and} primitive and restart the loop.
%
In the \code{par/or} loop variation, if the code does not terminate within a 
second, the second trail rejoins the composition (cancelling the first trail) 
and restarts the loop.
%
The two structures represent, respectively, the \emph{sampling} and 
\emph{timeout} patterns, which are common in embedded applications.
%
Note that the body of \textbf{\code{<...>}} may contain arbitrary code with 
nested compositions and awaits, but the described patterns will work as 
expected.

The conjunction of parallel compositions with the disciplined synchronous 
execution model provides precise information about the control flow of 
applications, such as which lines of executions can be active, and which 
variables are accessed in reaction to a specific event.
%
As a summary, the following safety properties hold for all programs that 
successfully compile in \CEU~\cite{ceu.sensys13}:
%
\begin{itemize}
\item Time-bounded reactions to the environment.
\item No concurrency in accesses to shared variables.
\item No concurrency in system calls sharing a resource.
\item Synchronization for timers in parallel.
\end{itemize}

\subsection{Dynamic memory allocation}

Dynamic memory is a fundamental mechanism in general-purpose programming, 
allowing programs to accommodate short-lived objects without keeping them in 
memory for the whole execution.

\CEU has no special support for memory allocation, relying on standard 
\emph{malloc} \& \emph{free} from $C$.
%
However, standard memory management raises a number of challenges to the design 
of safe applications:

\begin{enumerate}
\item \textbf{Run-time overhead:}
    Memory management requires extra run-time bookkeeping for the 
    allocation/reclamation algorithms.
    In real-time reactive applications, such as video games, even a small delay 
    may be noticed by the user.
\item \textbf{Unreproducible execution:}
    Successive executions of the same program may allocate memory in different 
    ways, possibly leading to different outcomes (e.g. an allocation fail).
\item \textbf{Reclamation hazards:}
    Properly reclaiming memory is far from trivial.
    A missed reclamation leads to a memory leak that wastes memory, while 
    reclaiming a memory block still in use leads to a dangling pointer that 
will eventually crash the application.
\end{enumerate}

A common alternative in the context of embedded systems is to use \emph{memory 
pools} as the underlying scheme to manage dynamic allocation.
A memory pool is a static buffer of \emph{N} predefined fixed-sized blocks of 
memory that can be used by an application.
%
With memory pools some of the threats raised above can be alleviated:

\begin{enumerate}
\item
The run-time overhead is minimal because implementations typically use simple 
arrays to hold the memory blocks.
For instance, both allocation and reclamation are \emph{O(1)} in TinyOS.
\item
Given that memory operations are simple and only handle fixed-size blocks, the 
execution is always deterministic and predictable.
\item
Memory pools are still manipulated through explicit allocation/reclamation 
operations.
Hence, all challenges to properly reclaim memory still hold.
\end{enumerate}

The biggest drawback of memory pools is the lack of flexibility


Regarding automatic reclamation of memory,

syntax to accommodate both

\begin{itemize}
    \item memory pools
    \item compositions / scoped
\end{itemize}

\subsection{Algorithmic-intensive computations}

asynchoronous primitive

parallelizable

\begin{itemize}
    \item share nothing policy
    \item lower priority
    \item automatic start/stop/schedule
\end{itemize}

\subsection{General-purpose applications}

\begin{itemize}
    \item games
    \item multimedia (NCL, Telemidia)
    \item network (DS, Noemi)
\end{itemize}

\begin{comment}

%
However, for soft real-time reactive systems, deadlines are not strict
Most general purpose reactive systems have soft real-time requirements,
(in contrast with hard real-time systems)
For hard real-time reactive systems, missing a critical scheduling deadline is 
unacceptable (e.g. a thread that controls the XXX for an aircraft).

although missing a deadline is undesired, xxx
control of an airplane

For soft real-time systems XXX

Our proposal aims to embrace the two limitation in the synchronous model
general-purpose, not hard
- combination of synchronous/asynchronous
- memory pools


FRP, depends on memory allocation
- our work

two sides of the spectrum
Ceu -> LuaGravity

static, compiler

dynamic, runtime

- reactive systems
    - emerging broad use \cite
    - embedded systems
    - guis, servers

- synchronous languages
    - ES: esterel
    - GP: FRP, elm
    - me: ceu, gvt

Software for embedded systems is usually developed in the C programming 
language, and the addition of a real-time operating system may extend it with 
preemptive and/or cooperative multithreading \cite{wsn.contiki,wsn.tos}.
However, concurrency in C requires a low-level exercise related to scheduling, 
synchronizing, and the life cycle of activities (i.e. creating and destroying 
threads).
%
Concurrency in C also lacks safety warranties, given that they are susceptible 
to unbounded execution, race conditions and deadlocks.
Nonetheless, safety is a fundamental  aspect in embedded systems, which have 
scarce resources and must run for long periods without human intervention.

The programming language \CEU~\cite{ceu.sensys13} developed as part of the 
proponent's PhD research in PUC--Rio is targeted at highly constrained embedded 
systems (such as Wireless Sensor Networks~\cite{wsn.survey}) and incorporates
features found in dataflow and imperative reactive languages 
\cite{lustre.ieee91, esterel.design}.
%
\CEU supports concurrent lines of execution that run in time steps and are 
allowed to share variables.
However, the synchronous and static nature of \CEU enables a compile time 
analysis that can enforce deterministic and memory-safe programs, offering a 
high-level and safe alternative to the predominating C based multithreaded 
systems.
The \CEU compiler generates code comparable to handcrafted C programs in terms 
of size and portability.

Currently, both data and control memory are managed manually, an approach that 
is known to be hard and error prone.
%
In this work we show how to extend a synchronous concurrent language to provide 
safe and automatic management of dynamic memory.
Our strategy reconciles data and control state into the single concept of 
\emph{organisms}, which provide multiple lines of execution with an object-like 
interface.
%
Unlike objects in Java, organisms are lexically scoped, and their life cycle is 
controlled following the structure of the program, rather than by runtime 
reachability algorithms.
%
As a result, memory reclamation is efficient, providing rich dynamic 
functionality as in Java, with little overhead in comparison to C-based 
systems.

\section{Objectives}

The main objective of our research during the sandwich period in Chalmers is to 
evaluate the applicability of  in the context of Wireless Sensor Networks 
and secure communications.
The evaluation involves quantitative measures (e.g. memory usage) and
qualitative measures (e.g. ease of programming).

The Distributed Computing and Systems group in the Chalmers University has an 
open PhD Sandwich position in the area of ``Secure Wireless Sensor Networks''.
The research position describes programming languages technologies as one of 
its focus:
\emph{``The Security group has developed the link between two areas of computer 
science: programming languages and computer security.
The group explores security models and enforcement mechanisms based on 
programming-language technology''}.

We believe that Wireless Sensor Networks are an ideal scenario to employ the 
 programming language, given it is targeted at highly constrained 
embedded systems, offering fine-grained concurrency, low memory overhead, and 
safety warranties.

Many number of software services are required when building a sensor network 
application.
The technique of layering services on top of each other, building functionality 
on top of functionality and, at the same time, separating them into manageable 
units are a powerful approach.

As an illustrative example, WSN applications typically run tweaked versions of 
classical distributed algorithms, such as \emph{topology discovery}, 
\emph{leader election}, \emph{broadcast}, etc \cite{ds.andrews}.
These algorithms give support for more general purpose applications and must 
run continuously with them, given the dynamicity of WSNs.

The WSN group at PUC--Rio is currently working on developing a library of a set 
of such classical algorithms.
With , these algorithms are easily composed with a parallel construct, 
making the main application run concurrently with the distributed algorithm 
seamlessly.
The language detects any inconsistency with the composition, such as concurrent 
access to shared variables and unreachable code.
This idea can be extended to algorithms used and/or developed by the DCS group 
in Chalmers (e.g. \cite{dcs.clusters}).

We are also planning to investigate ways to describe an approach for 
synthesizing data representations for concurrent programs.
It is part of the process to evolve the language together with the DCS group 
when identifying new requirements not currently addressed.

The DCS group in Chalmers also does research in many programming languages 
topics, which can also be explored during the PhD Sandwich 
\cite{dcs.lock_free,dcs.transactional,dcs.manycore}.
The group has a research library of concurrent constructs 
(NOBLE\footnote{http://www.cse.chalmers.se/research/group/noble/}) and a 
testbed of applications ranging from SmartGrid ones to connected car 
applications (GULLIVER\footnote{http://www.chalmers.se/hosted/gulliver-en/}).

The following list of research topics, aligned with the programming model of 
, was extracted from the DCS website:

\begin{itemize}
\item Investigate new techniques for achieving high parallelism and 
      fault-tolerance in distributed or parallel software.
\item Evaluate the performance of non-blocking synchronization in parallel 
      application and system software.
\item Non-blocking/fine-grain synchronization, aiming at increased parallelism, 
      fault-tolerance, avoiding convoy effects and priority inversion.
\item Enhancing performance by cooperative scheduling-and-synchronization.
\end{itemize}

\section{Methodology}

During the period of the PhD Sandwich, we intend to develop fully working WSN 
applications in  in order to evaluate its viability as an
alternative to the current employed technologies.
We will use quantitative and qualitative metrics for the relevant aspects in
WSNs, and compare the implementations of applications in  and other 
languages (e.g. C).

An existing work \cite{wsn.comparison} measures the performance of different 
programming languages regarding memory usage, battery
consumption, and responsiveness specifically for WSNs.
These aspects are of extreme importance, given the severe hardware constraints 
in this context.

We also consider safety an important aspect, as motes must run for long periods 
without human intervention. Finally, high expressiveness, is desired for any 
programming language in any context.

Follows the list of aspects we will evaluate during our research:

\begin{itemize}
\item Memory usage: how much applications use in terms of volatile (RAM) and 
      non-volatile (ROM) memory.
\item Battery consumption: how much energy applications consume.
\item Responsiveness: how fast applications acknowledge high-priority requests 
      (e.g. radio messages).
\item Safety: which warranties the language offers, releasing the programmer 
      from such concerns.
\item Expressiveness: how easy applications can be developed and maintained.
\end{itemize}

The first three aspects can be easily evaluated with quantitative metrics, 
while the last two require a more in-depth
analysis.

Initially, we will port to  a set of existing applications developed in 
other languages and compare the quantitative aspects of the implementations.  
The results immediately provide feedback regarding the implementations in 
, which can be used to improve the language.

Then, we will focus on developing new applications with higher complexity in 
order to evaluate the qualitative aspects.
We can still use quantitative measures such as number of lines of code and 
period of development to help on the evaluation.

\section{Schedule}

Our proposal includes a six-month schedule that we intend to follow during the 
sandwich period:

\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | c | c | c | c | c | c | }
\hline
    & M1 & M2 & M3 & M4 & M5 & M6 \\ \hline

Presentation of        & X &   & X &   & X &   \\ \hline
Development of existing apps & X & X &   &   &   &   \\ \hline
Improvements on        &   & x & X & x & X &   \\ \hline
Development of new apps      &   &   & X & X & X &   \\ \hline
Paper                        &   &   &   &   & X & X \\ \hline
Other activities             & x & x & x & x & x & x \\ \hline
\end{tabular}
\linebreak
{\small(\textbf{X} cells indicate high activity, while \textbf{x} cells 
indicate low activity)}
\end{center}
\end{table}

\begin{description}

\item[Months 1--2:]

During the first month, we will present the language  to the research 
group, focusing on its applicability to WSNs and
on how it differs from existing systems.

Then, with the support of the group, we will choose existing WSN applications 
to be ported to  in order to perform the
quantitative analysis of the implementations until the end of the second month.

\item[Months 3--4:]

With the work on existing applications, we will collect a comprehensive 
feedback to be used for improvements on the
language.

We will also present the achievements of the first two months, and discuss the 
development of new applications with
higher complexity for the next two months.

\item[Months 5--6:]

By the beginning of the fifth month, we expect to have developed some complex 
applications that can be used in a in-depth
qualitative analysis of the language.

Both the quantitative and qualitative analysis will be used in a paper to be 
written to a conference on WSNs.

\item[Months 1--6:]

We also have interest in exploring other research areas of the group related to 
programming languages and distributed
systems.

\end{description}

\section{Expected Results}

By the end of the PhD Sandwich, we expect that  becomes a real 
alternative for the development of fully working WSN applications.
Our methodology involves a quantitative analysis that provides immediate 
feedback regarding key aspects in WSNs, such as memory usage and battery 
consumption.
Hence, we can evolve the language in a small development cycle.

We have already presented a short paper about  in the doctoral colloquium 
of SenSys last year \cite{ceu.sensys11}, with some initial experiments that 
show competitive results in terms of memory usage and responsiveness.
With a broader usage, we will have more confidence on the measurements and 
achieve even better results.

We also expect that the ongoing research in our WSN group at PUC--Rio will take 
advantage of the interchange with the group in Chalmers and vice-versa.
Both groups share common research interests and a continuous relationship may 
arise from this first experience.
For instance, the library of distributed algorithms for WSNs being developed by 
the group at PUC--Rio is open-source and can be more easily adopted by the 
group at Chalmers through this interchange program.

We intend to write a full paper to a top conference together with the group in 
Chalmers to describe the advances of  in the context of WSNs:

\begin{itemize}
\item ACM/IEEE Conference on Information Processing in Sensor Networks (IPSN).  
      Submission deadline expected to October 2012.
\item ACM Conference on Embedded Networked Sensor Systems (SenSys).
      Submission deadline expected to April 2013.
\end{itemize}

Another outcome of our research could be the adoption of  in new projects 
in the DCS group in Chalmers, which need not be directly related to research in 
programming languages.

\section{Researchers}

\begin{description}

\item[PUC--Rio (proponent):]
\hspace{1mm}

\textbf{Francisco Sant'Anna} is a third year Ph.D. student in the Computer 
Science department at PUC-Rio. He earned his BSc (2003) and MSc (2007) degrees 
also in the Computer Science department at PUC-Rio.

The current title of his PhD thesis is ``: Embedded, Safe, and Reactive 
Programming'', which is expected to be concluded in September 2013.
His advisors are Prof. Roberto Ierusalimschy and Prof. Noemi Rodriguez, which 
actuate, respectively, in the field of programming languages and distributed 
systems.

\textbf{Prof. Roberto Ierusalimschy} is an associate professor of informatics 
at PUC-Rio (Pontifical University in Rio de Janeiro).
He is the leading architect of the Lua programming language and the author of 
Programming in Lua.\cite{lua.pil}

His research activities currently focus on programming languages, mainly 
alternative languages such as scripting languages and domain-specific 
languages.

\textbf{Prof. Noemi Rodriguez} is an associate professor of informatics at 
PUC--Rio.
Her research interests include the area of concurrent and distributed 
programming, with an emphasis on the role of programming languages in this 
context.
She also leads the Wireless Sensor Networks research group at PUC--Rio.

\item[Chalmers University (host):]
\hspace{1mm}

\textbf{Prof. Philippas Tsigas} is a professor in the Department of Computing 
Science and Engineering at Chalmers University.
He is the co-leader of the Distributed Computing and Systems Research Group.
His research interests center on distributed/parallel computing and systems and 
information visualization in general.

Homepage:
\url{http://www.cse.chalmers.se/~tsigas/index.html}

\end{description}

\end{comment}

\bibliographystyle{acm}
\bibliography{other,my}

\end{document}

